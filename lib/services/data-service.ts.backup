"use client";

import { db } from "@/lib/db";
// import type { Transaction, Goal, Contact, Investment, Budget, UserSettings, Category, Tag } from "@/lib/s"; // Campo removido: não existe no schema atual
import { Decimal } from "@prisma/client/runtime/library";

/**
 * Serviço de dados que substitui o localStorage
 * Fornece uma interface unificada para acessar dados do banco de dados
 */
export class DataService {
  private static instance: DataService;
  private cache = new Map<string, { data: any; timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutos

  static getInstance(): DataService {
    if (!DataService.instance) {
      DataService.instance = new DataService();
    }
    return DataService.instance;
  }

  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

//   private getCacheKey(: string, params?: any): string { // Campo removido: não existe no schema atual

  }

  private getFromCache<T>(key: string): T | null {
    const cached = this.cache.get(key);
    if (!cached) return null;

    if (Date.now() - cached.timestamp > this.CACHE_TTL) {
      this.cache.delete(key);
      return null;
    }

    return cached.data;
  }

  private setCache<T>(key: string, data: T): void {
    this.cache.set(key, { data, timestamp: Date.now() });
  }

  private invalidateCache(pattern: string): void {
    for (const key of this.cache.keys()) {
      if (key.startsWith(pattern)) {
        this.cache.delete(key);
      }
    }
  }

  // ==================== TRANSAÇÕES ====================

  /**
   * Obtém todas as transações
   */
  async getTransactions(filters?: {
    startDate?: string;
    endDate?: string;
    category?: string;

    search?: string;
  }): Promise<Transaction[]> {
    const cacheKey = this.getCacheKey('transactions', filters);
    const cached = this.getFromCache<Transaction[]>(cacheKey);
    if (cached) return cached;

    try {
      const where: any = {
        userId: "user_1"
      };

      if (filters?.startDate && filters?.endDate) {
        where.date = {
          gte: new Date(filters.startDate),
          lte: new Date(filters.endDate)};
      }

      if (filters?.category) {
        where.category = filters.category;
      }

//       if (filters?.type && (filters.type === "income" || filters. === "expense")) { // Campo removido: não existe no schema atual
//         if (filters. === "income") { // Campo removido: não existe no schema atual
          where.amount = { gt: 0 };
        } else {
          where.amount = { lt: 0 };
        }
      }

      if (filters?.search) {
        where.OR = [
          { description: { contains: filters.search, mode: "insensitive" } },
          { category: { contains: filters.search, mode: "insensitive" } },
        ];
      }

      const transactions = await db.transaction.findMany({
        where,
        include: { account: true },
        orderBy: { date: "desc" }});

      const formattedTransactions: Transaction[] = transactions.map((t) => ({
        id: t.id,
        description: t.description,
        amount: Math.abs(Number(t.amount)),

        category: t.category,
        account: t.account.name,
        date: t.date.toISOString(),
        notes: t.notes || undefined,


        recurring: false, // TODO: implementar campo recurring
        sharedWith: t.sharedWith ? t.sharedWith.split(",") : undefined,
        createdAt: t.createdAt.toISOString(),
        updatedAt: t.updatedAt.toISOString()}));

      this.setCache(cacheKey, formattedTransactions);
      return formattedTransactions;
    } catch (error) {
      console.error("Erro ao buscar transações:", error);
      return [];
    }
  }

  /**
   * Salva uma nova transação
   */
  async saveTransaction(
    transaction: Omit<Transaction, "id" | "createdAt" | "updatedAt">
  ): Promise<Transaction | null> {
    try {
      // Garantir que existe uma conta
      let account = await db.account.findFirst({
        where: { name: transaction.account }});

      if (!account) {
        account = await db.account.create({
          data: {
            userId: "user_1",
            name: transaction.account,

            balance: 0}});
      }

      const dbTransaction = await db.transaction.create({
        data: {
          userId: "user_1",
          accountId: account.id,
          description: transaction.description,


          category: transaction.category,
          date: new Date(transaction.date),
          notes: transaction.notes,

          sharedWith: transaction.sharedWith?.join(",")},
        include: { account: true }});

      this.invalidateCache('transactions');

      return {
        id: dbTransaction.id,
        description: dbTransaction.description,
        amount: Math.abs(Number(dbTransaction.amount)),

        category: dbTransaction.category,
        account: dbTransaction.account.name,
        date: dbTransaction.date.toISOString(),
        notes: dbTransaction.notes || undefined,


        recurring: false,
        sharedWith: dbTransaction.sharedWith ? dbTransaction.sharedWith.split(",") : undefined,
        createdAt: dbTransaction.createdAt.toISOString(),
        updatedAt: dbTransaction.updatedAt.toISOString()};
    } catch (error) {
      console.error("Erro ao salvar transação:", error);
      return null;
    }
  }

  /**
   * Atualiza uma transação
   */
  async updateTransaction(id: string, updates: Partial<Transaction>): Promise<Transaction | null> {
    try {
      const updateData: any = {};

      if (updates.description) updateData.description = updates.description;
      if (updates.amount !== undefined) {

      }
//       if (updates.type) updateData.type = updates.; // Campo removido: não existe no schema atual
      if (updates.category) updateData.category = updates.category;
      if (updates.date) updateData.date = new Date(updates.date);
      if (updates.notes) updateData.notes = updates.notes;
      if (updates.sharedWith) updateData.sharedWith = updates.sharedWith.join(",");
//       if (updates.installments) updateData.installments = updates.; // Campo removido: não existe no schema atual
//       if (updates.currentInstallment) updateData.currentInstallment = updates.; // Campo removido: não existe no schema atual

      const dbTransaction = await db.transaction.update({
        where: { id },
        data: updateData,
        include: { account: true }});

      this.invalidateCache('transactions');

      return {
        id: dbTransaction.id,
        description: dbTransaction.description,
        amount: Math.abs(Number(dbTransaction.amount)),

        category: dbTransaction.category,
        account: dbTransaction.account.name,
        date: dbTransaction.date.toISOString(),
        notes: dbTransaction.notes || undefined,


        recurring: false,
        sharedWith: dbTransaction.sharedWith ? dbTransaction.sharedWith.split(",") : undefined,
        createdAt: dbTransaction.createdAt.toISOString(),
        updatedAt: dbTransaction.updatedAt.toISOString()};
    } catch (error) {
      console.error("Erro ao atualizar transação:", error);
      return null;
    }
  }

  /**
   * Remove uma transação
   */
  async deleteTransaction(id: string): Promise<boolean> {
    try {
      await db.transaction.delete({ where: { id } });
      this.invalidateCache('transactions');
      return true;
    } catch (error) {
      console.error("Erro ao deletar transação:", error);
      return false;
    }
  }

  // ==================== CONTAS ====================

  /**
   * Obtém todas as contas
   */
  async getAccounts(): Promise<any[]> {
    const cacheKey = this.getCacheKey('accounts');
    const cached = this.getFromCache<any[]>(cacheKey);
    if (cached) return cached;

    try {
      const accounts = await db.account.findMany({
        where: { userId: "user_1" },
        orderBy: { createdAt: "desc" }});

      const formattedAccounts = accounts.map((account) => ({
        id: account.id,
        name: account.name,

        balance: Number(account.balance),
        description: account.description,
        isActive: account.isActive,
        createdAt: account.createdAt.toISOString(),
        updatedAt: account.updatedAt.toISOString()}));

      this.setCache(cacheKey, formattedAccounts);
      return formattedAccounts;
    } catch (error) {
      console.error("Erro ao buscar contas:", error);
      return [];
    }
  }

  // ==================== METAS ====================

  /**
   * Obtém todas as metas
   */
  async getGoals(): Promise<Goal[]> {
    const cacheKey = this.getCacheKey('goals');
    const cached = this.getFromCache<Goal[]>(cacheKey);
    if (cached) return cached;

    try {
      const goals = await db.goal.findMany({
        where: { userId: "user_1" },
        orderBy: { createdAt: "desc" }});

      const formattedGoals: Goal[] = goals.map((goal) => ({
        id: goal.id,
        name: goal.name,
        description: goal.description || undefined,
        target: Number(goal.targetAmount),
        current: Number(goal.currentAmount),
        deadline: goal.targetDate?.toISOString(),
        category: goal.category,
        priority: goal.priority as "high" | "medium" | "low",
        createdAt: goal.createdAt.toISOString(),
        updatedAt: goal.updatedAt.toISOString()}));

      this.setCache(cacheKey, formattedGoals);
      return formattedGoals;
    } catch (error) {
      console.error("Erro ao buscar metas:", error);
      return [];
    }
  }

  /**
   * Salva uma nova meta
   */
  async saveGoal(
    goal: Omit<Goal, "id" | "createdAt" | "updatedAt">
  ): Promise<Goal | null> {
    try {
      const dbGoal = await db.goal.create({
        data: {
          userId: "user_1",
          name: goal.name,
          description: goal.description,
          targetAmount: new Decimal(goal.target),
          currentAmount: new Decimal(goal.current || 0),
          targetDate: goal.deadline ? new Date(goal.deadline) : null,
          category: goal.category,
          priority: goal.priority || "medium",
          status: "active"}});

      this.invalidateCache('goals');

      return {
        id: dbGoal.id,
        name: dbGoal.name,
        description: dbGoal.description || undefined,
        target: Number(dbGoal.targetAmount),
        current: Number(dbGoal.currentAmount),
        deadline: dbGoal.targetDate?.toISOString(),
        category: dbGoal.category,
        priority: dbGoal.priority as "high" | "medium" | "low",
        createdAt: dbGoal.createdAt.toISOString(),
        updatedAt: dbGoal.updatedAt.toISOString()};
    } catch (error) {
      console.error("Erro ao salvar meta:", error);
      return null;
    }
  }

  /**
   * Atualiza uma meta
   */
  async updateGoal(id: string, updates: Partial<Goal>): Promise<Goal | null> {
    try {
      const updateData: any = {};

      if (updates.name) updateData.name = updates.name;
      if (updates.description) updateData.description = updates.description;
      if (updates.target !== undefined) updateData.targetAmount = new Decimal(updates.target);
      if (updates.current !== undefined) updateData.currentAmount = new Decimal(updates.current);
      if (updates.deadline) updateData.targetDate = new Date(updates.deadline);
      if (updates.category) updateData.category = updates.category;
      if (updates.priority) updateData.priority = updates.priority;

      const dbGoal = await db.goal.update({
        where: { id },
        data: updateData});

      this.invalidateCache('goals');

      return {
        id: dbGoal.id,
        name: dbGoal.name,
        description: dbGoal.description || undefined,
        target: Number(dbGoal.targetAmount),
        current: Number(dbGoal.currentAmount),
        deadline: dbGoal.targetDate?.toISOString(),
        category: dbGoal.category,
        priority: dbGoal.priority as "high" | "medium" | "low",
        createdAt: dbGoal.createdAt.toISOString(),
        updatedAt: dbGoal.updatedAt.toISOString()};
    } catch (error) {
      console.error("Erro ao atualizar meta:", error);
      return null;
    }
  }

  /**
   * Remove uma meta
   */
  async deleteGoal(id: string): Promise<boolean> {
    try {
      await db.goal.delete({ where: { id } });
      this.invalidateCache('goals');
      return true;
    } catch (error) {
      console.error("Erro ao deletar meta:", error);
      return false;
    }
  }

  // ==================== ORÇAMENTOS ====================

  /**
   * Busca todos os orçamentos
   */
  async getBudgets(): Promise<Budget[]> {
    try {
      const dbBudgets = await db.budget.findMany({
        where: { userId: this.getCurrentUserId() },
        orderBy: { createdAt: 'desc' }
      });

      return dbBudgets.map(budget => ({
        id: budget.id,
        category: budget.category,
        amount: Number(budget.amount),
        spent: Number(budget.spent),
        period: budget.period as "monthly" | "weekly" | "yearly",
        startDate: budget.startDate.toISOString(),
        endDate: budget.endDate.toISOString(),
        description: budget.description || undefined,
        isActive: budget.isActive,
        createdAt: budget.createdAt.toISOString(),
        updatedAt: budget.updatedAt.toISOString()
      }));
    } catch (error) {
      console.error('Erro ao buscar orçamentos:', error);
      // localStorage fallback removido - dados agora vêm apenas do banco
      console.warn('Falha ao carregar orçamentos do banco de dados, retornando array vazio');
      return [];
    }
  }

  /**
   * Salva um novo orçamento
   */
  async saveBudget(budget: Omit<Budget, 'id' | 'createdAt' | 'updatedAt'>): Promise<Budget> {
    try {
      const dbBudget = await db.budget.create({
        data: {
          userId: this.getCurrentUserId(),
          category: budget.category,
          amount: new Decimal(budget.amount),
          spent: new Decimal(budget.spent),
          period: budget.period,
          startDate: new Date(budget.startDate),
          endDate: new Date(budget.endDate),
          description: budget.description,
          isActive: budget.isActive
        }
      });

      this.invalidateCache('budgets');

      return {
        id: dbBudget.id,
        category: dbBudget.category,
        amount: Number(dbBudget.amount),
        spent: Number(dbBudget.spent),
        period: dbBudget.period as "monthly" | "weekly" | "yearly",
        startDate: dbBudget.startDate.toISOString(),
        endDate: dbBudget.endDate.toISOString(),
        description: dbBudget.description || undefined,
        isActive: dbBudget.isActive,
        createdAt: dbBudget.createdAt.toISOString(),
        updatedAt: dbBudget.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao salvar orçamento:', error);
      // Fallback to localStorage
//       if (of window !== 'undefined') { // Campo removido: não existe no schema atual
        const budgets = this.getFromLocalStorage<Budget>('budgetCategories');
        const newBudget: Budget = {
          ...budget,
          id: this.generateId(),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        // localStorage fallback removido - dados agora são salvos apenas no banco
        console.warn('Falha ao salvar orçamento no banco de dados');
        throw error;
      }
      throw error;
    }
  }

  /**
   * Atualiza um orçamento
   */
  async updateBudget(id: string, updates: Partial<Budget>): Promise<void> {
    try {
      const updateData: any = {};

      if (updates.category) updateData.category = updates.category;
      if (updates.amount !== undefined) updateData.amount = new Decimal(updates.amount);
      if (updates.spent !== undefined) updateData.spent = new Decimal(updates.spent);
      if (updates.period) updateData.period = updates.period;
      if (updates.startDate) updateData.startDate = new Date(updates.startDate);
      if (updates.endDate) updateData.endDate = new Date(updates.endDate);
      if (updates.description !== undefined) updateData.description = updates.description;
      if (updates.isActive !== undefined) updateData.isActive = updates.isActive;

      await db.budget.update({
        where: { id, userId: this.getCurrentUserId() },
        data: updateData
      });

      this.invalidateCache('budgets');
    } catch (error) {
      console.error('Erro ao atualizar orçamento:', error);
      // localStorage fallback removido - dados agora são atualizados apenas no banco
      console.warn('Falha ao atualizar orçamento no banco de dados');
      throw error;
    }
  }

  /**
   * Remove um orçamento
   */
  async deleteBudget(id: string): Promise<void> {
    try {
      await db.budget.delete({
        where: { id, userId: this.getCurrentUserId() }
      });
      this.invalidateCache('budgets');
    } catch (error) {
      console.error('Erro ao deletar orçamento:', error);
      
    try {
      const settings = await db.userSettings.findUnique({
        where: {

            userId: this.getCurrentUserId()}
        }
      });

      if (!settings) return null;

      return {
        id: settings.id,
        userId: settings.userId,

        data: JSON.parse(settings.data),
        createdAt: settings.createdAt.toISOString(),
        updatedAt: settings.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao buscar configurações:', error);
      return null;
    }
  }

  /**
   * Salva configurações do usuário
   */
/**
   * Salva configurações do usuário
   */
  async saveUserSettings(data: any): Promise<UserSettings> {
    try {
      const settings = await db.userSettings.upsert({
        where: {
          userId: this.getCurrentUserId()
        },
        update: {
          data: JSON.stringify(data)
        },
        create: {
          userId: this.getCurrentUserId(),
          data: JSON.stringify(data)
        }
      });

      return {
        id: settings.id,
        userId: settings.userId,
        data: JSON.parse(settings.data),
        createdAt: settings.createdAt.toISOString(),
        updatedAt: settings.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao salvar configurações:', error);
      throw error;
    }
  },
        update: {
          data: JSON.stringify(data)
        },
        create: {
          userId: this.getCurrentUserId(),

          data: JSON.stringify(data)
        }
      });

      return {
        id: settings.id,
        userId: settings.userId,

        data: JSON.parse(settings.data),
        createdAt: settings.createdAt.toISOString(),
        updatedAt: settings.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao salvar configurações:', error);
      throw error;
    }
  }

  /**
   * Busca todas as categorias
   */
  async getCategories(): Promise<Category[]> {
    try {
      const dbCategories = await db.category.findMany({
        where: { userId: this.getCurrentUserId() },
        orderBy: { name: 'asc' }
      });

      return dbCategories.map(category => ({
        id: category.id,
        userId: category.userId,
        name: category.name,
        color: category.color || undefined,
        icon: category.icon || undefined,
        isActive: category.isActive,
        createdAt: category.createdAt.toISOString(),
        updatedAt: category.updatedAt.toISOString()
      }));
    } catch (error) {
      console.error('Erro ao buscar categorias:', error);
      // localStorage fallback removido - dados agora vêm apenas do banco
      console.warn('Falha ao carregar categorias do banco de dados, retornando array vazio');
      return [];
    }
  }

  /**
   * Salva uma nova categoria
   */
  async saveCategory(category: Omit<Category, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Category> {
    try {
      const dbCategory = await db.category.create({
        data: {
          userId: this.getCurrentUserId(),
          name: category.name,

          color: category.color,
          icon: category.icon,
          isActive: category.isActive
        }
      });

      return {
        id: dbCategory.id,
        userId: dbCategory.userId,
        name: dbCategory.name,

        color: dbCategory.color || undefined,
        icon: dbCategory.icon || undefined,
        isActive: dbCategory.isActive,
        createdAt: dbCategory.createdAt.toISOString(),
        updatedAt: dbCategory.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao salvar categoria:', error);
      throw error;
    }
  }

  /**
   * Atualiza uma categoria
   */
  async updateCategory(id: string, updates: Partial<Category>): Promise<Category> {
    try {
      const dbCategory = await db.category.update({
        where: { id },
        data: {
          name: updates.name,

          color: updates.color,
          icon: updates.icon,
          isActive: updates.isActive
        }
      });

      return {
        id: dbCategory.id,
        userId: dbCategory.userId,
        name: dbCategory.name,

        color: dbCategory.color || undefined,
        icon: dbCategory.icon || undefined,
        isActive: dbCategory.isActive,
        createdAt: dbCategory.createdAt.toISOString(),
        updatedAt: dbCategory.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao atualizar categoria:', error);
      throw error;
    }
  }

  /**
   * Deleta uma categoria
   */
  async deleteCategory(id: string): Promise<void> {
    try {
      await db.category.delete({
        where: { id }
      });
    } catch (error) {
      console.error('Erro ao deletar categoria:', error);
      throw error;
    }
  }

  /**
   * Busca todas as tags
   */
  async getTags(): Promise<Tag[]> {
    try {
      const dbTags = await db.tag.findMany({
        where: { userId: this.getCurrentUserId() },
        orderBy: { name: 'asc' }
      });

      return dbTags.map(tag => ({
        id: tag.id,
        userId: tag.userId,
        name: tag.name,
        color: tag.color || undefined,
        isActive: tag.isActive,
        createdAt: tag.createdAt.toISOString(),
        updatedAt: tag.updatedAt.toISOString()
      }));
    } catch (error) {
      console.error('Erro ao buscar tags:', error);
      // localStorage fallback removido - dados agora vêm apenas do banco
      console.warn('Falha ao carregar tags do banco de dados, retornando array vazio');
      return [];
    }
  }

  /**
   * Salva uma nova tag
   */
  async saveTag(tag: Omit<Tag, 'id' | 'userId' | 'createdAt' | 'updatedAt'>): Promise<Tag> {
    try {
      const dbTag = await db.tag.create({
        data: {
          userId: this.getCurrentUserId(),
          name: tag.name,
          color: tag.color,
          isActive: tag.isActive
        }
      });

      return {
        id: dbTag.id,
        userId: dbTag.userId,
        name: dbTag.name,
        color: dbTag.color || undefined,
        isActive: dbTag.isActive,
        createdAt: dbTag.createdAt.toISOString(),
        updatedAt: dbTag.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao salvar tag:', error);
      throw error;
    }
  }

  /**
   * Atualiza uma tag
   */
  async updateTag(id: string, updates: Partial<Tag>): Promise<Tag> {
    try {
      const dbTag = await db.tag.update({
        where: { id },
        data: {
          name: updates.name,
          color: updates.color,
          isActive: updates.isActive
        }
      });

      return {
        id: dbTag.id,
        userId: dbTag.userId,
        name: dbTag.name,
        color: dbTag.color || undefined,
        isActive: dbTag.isActive,
        createdAt: dbTag.createdAt.toISOString(),
        updatedAt: dbTag.updatedAt.toISOString()
      };
    } catch (error) {
      console.error('Erro ao atualizar tag:', error);
      throw error;
    }
  }

  /**
   * Deleta uma tag
   */
  async deleteTag(id: string): Promise<void> {
    try {
      await db.tag.delete({
        where: { id }
      });
    } catch (error) {
      console.error('Erro ao deletar tag:', error);
      throw error;
    }
  }

  // ==================== CONTATOS ====================

  /**
   * Obtém todos os contatos
   */
  async getContacts(): Promise<Contact[]> {
    const cacheKey = this.getCacheKey('contacts');
    const cached = this.getFromCache<Contact[]>(cacheKey);
    if (cached) return cached;

    try {
      const contacts = await db.contact.findMany({
        where: { userId: "user_1" },
        orderBy: { createdAt: "desc" }});

      const formattedContacts: Contact[] = contacts.map((contact) => ({
        id: contact.id,
        name: contact.name,
        email: contact.email || "",
        phone: contact.phone,
        createdAt: contact.createdAt.toISOString()}));

      this.setCache(cacheKey, formattedContacts);
      return formattedContacts;
    } catch (error) {
      console.error("Erro ao buscar contatos:", error);
      return [];
    }
  }

  // ==================== INVESTIMENTOS ====================

  /**
   * Obtém todos os investimentos
   */
  async getInvestments(): Promise<Investment[]> {
    const cacheKey = this.getCacheKey('investments');
    const cached = this.getFromCache<Investment[]>(cacheKey);
    if (cached) return cached;

    try {
      const investments = await db.investment.findMany({
        where: { userId: "user_1" },
        orderBy: { createdAt: "desc" }});

      const formattedInvestments: Investment[] = investments.map((investment) => ({
        id: investment.id,
        operation: "buy" as const, // TODO: implementar campo operation

        ticker: investment.symbol,
        name: investment.name,
        quantity: Number(investment.quantity),
        price: Number(investment.purchasePrice),
        totalValue: Number(investment.quantity) * Number(investment.purchasePrice),
        date: investment.purchaseDate.toISOString(),
        account: investment.broker || "Conta Principal",
        fees: Number(investment.fees),
        sector: undefined, // TODO: implementar campo sector
        createdAt: investment.createdAt.toISOString(),
        updatedAt: investment.updatedAt.toISOString()}));

      this.setCache(cacheKey, formattedInvestments);
      return formattedInvestments;
    } catch (error) {
      console.error("Erro ao buscar investimentos:", error);
      return [];
    }
  }

  // ==================== UTILITÁRIOS ====================

  /**
   * Limpa todo o cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Salva backup de transações
   */
  async saveTransactionsBackup(transactions: Transaction[]): Promise<void> {
    try {
      // Salvar transações no banco de dados se não existirem
      for (const transaction of transactions) {
        const existing = await db.transaction.findFirst({
          where: { id: transaction.id }
        });
        
        if (!existing) {
          await this.saveTransaction(transaction);
        }
      }
    } catch (error) {
      console.error("Erro ao salvar backup de transações:", error);
    }
  }

  /**
   * Busca transações com filtros
   */
  async searchTransactions(filters: {

    category?: string;
    account?: string;
    startDate?: string;
    endDate?: string;
    search?: string;
  }): Promise<Transaction[]> {
    return this.getTransactions(filters);
  }

  /**
   * Obtém estatísticas de transações por período
   */
  async getStats(period?: string): Promise<{
    totalIncome: number;
    totalExpenses: number;
    balance: number;
    transactionCount: number;
    categoryBreakdown: Array<{ category: string; amount: number; count: number }>;
  }> {
    try {
      let filters: any = {};
      
      // Aplicar filtro de período se especificado
      if (period) {
        const now = new Date();
        let startDate: Date;
        
        switch (period) {
          case 'week':
            startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
            break;
          case 'month':
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            break;
          case 'year':
            startDate = new Date(now.getFullYear(), 0, 1);
            break;
          default:
            startDate = new Date(0); // Todas as transações
        }
        
        filters.startDate = startDate.toISOString();
        filters.endDate = now.toISOString();
      }
      
      const transactions = await this.getTransactions(filters);
      
      const totalIncome = transactions
//         .filter(t => t. === "income") // Campo removido: não existe no schema atual
        .reduce((sum, t) => sum + t.amount, 0);
        
      const totalExpenses = transactions
//         .filter(t => t. === "expense") // Campo removido: não existe no schema atual
        .reduce((sum, t) => sum + t.amount, 0);
      
      // Agrupar por categoria
      const categoryMap = new Map<string, { amount: number; count: number }>();
      
      transactions.forEach(transaction => {
        const category = transaction.category;
        const existing = categoryMap.get(category) || { amount: 0, count: 0 };
        
        categoryMap.set(category, {
          amount: existing.amount + transaction.amount,
          count: existing.count + 1
        });
      });
      
      const categoryBreakdown = Array.from(categoryMap.entries()).map(([category, data]) => ({
        category,
        amount: data.amount,
        count: data.count
      }));
      
      return {
        totalIncome,
        totalExpenses,
        balance: totalIncome - totalExpenses,
        transactionCount: transactions.length,
        categoryBreakdown
      };
    } catch (error) {
      console.error("Erro ao calcular estatísticas:", error);
      return {
        totalIncome: 0,
        totalExpenses: 0,
        balance: 0,
        transactionCount: 0,
        categoryBreakdown: []
      };
    }
  }

  /**
   * Obtém estatísticas gerais do sistema
   */
  async getGeneralStats(): Promise<{
    totalTransactions: number;
    totalAccounts: number;
    totalGoals: number;
    totalContacts: number;
    totalInvestments: number;
  }> {
    try {
      const [transactions, accounts, goals, contacts, investments] = await Promise.all([
        this.getTransactions(),
        this.getAccounts(),
        this.getGoals(),
        this.getContacts(),
        this.getInvestments(),
      ]);

      return {
        totalTransactions: transactions.length,
        totalAccounts: accounts.length,
        totalGoals: goals.length,
        totalContacts: contacts.length,
        totalInvestments: investments.length};
    } catch (error) {
      console.error("Erro ao buscar estatísticas gerais:", error);
      return {
        totalTransactions: 0,
        totalAccounts: 0,
        totalGoals: 0,
        totalContacts: 0,
        totalInvestments: 0};
    }
  }
}

// Instância singleton
export const dataService = DataService.getInstance();

// Compatibilidade com a interface antiga do storage
export const storage = {
  // Transações
  getTransactions: () => dataService.getTransactions(),
  saveTransaction: (transaction: Omit<Transaction, "id" | "createdAt" | "updatedAt">) => 
    dataService.saveTransaction(transaction),
  updateTransaction: (id: string, updates: Partial<Transaction>) => 
    dataService.updateTransaction(id, updates),
  deleteTransaction: (id: string) => dataService.deleteTransaction(id),
  
  // Metas
  getGoals: () => dataService.getGoals(),
  saveGoal: (goal: Omit<Goal, "id" | "createdAt" | "updatedAt">) => 
    dataService.saveGoal(goal),
  updateGoal: (id: string, updates: Partial<Goal>) => 
    dataService.updateGoal(id, updates),
  deleteGoal: (id: string) => dataService.deleteGoal(id),
  
  // Contatos
  getContacts: () => dataService.getContacts(),
  
  // Investimentos
  getInvestments: () => dataService.getInvestments(),
  
  // Contas
  getAccounts: () => dataService.getAccounts(),
  
  // Utilitários
  clearCache: () => dataService.clearCache()};